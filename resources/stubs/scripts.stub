window._aquastrap =  window._aquastrap || {
    component: [],
    config: {success: () => {}, error: () => {}}
};

function _hasProperty(obj, prop) {
    const _has = Object.prototype.hasOwnProperty;

    return _has.call(obj, prop)
};

function _manifestNetworkHandler(url, successCallback = null, errorCallback = null) {
    return async (formData = {}) => {
        let options = {
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json',
                "X-Requested-With": "XMLHttpRequest",
                "X-CSRF-Token": document.querySelector('meta[name="csrf-token"]').content
            },
            credentials: "same-origin",
            method: 'POST',
            body: JSON.stringify(formData),
        };

        const reponse = await fetch(url, options)
        .then(res => {
            if(res.status >= 400) {
                throw new Error(res.status + ' Network request failed!');
            }

            return res.json();
        })
        .then(function(data) {
            if (typeof successCallback === 'function') { successCallback(data); }

            return data;
        })
        .catch(function(error) {
            if (typeof errorCallback === 'function') { errorCallback(error); }

            throw new Error(error);
        });

        return reponse;
    };
}

function _replicatePublicMethods(routes, id, successCallback = null, errorCallback = null) {
    let methods = {};

    for (const [name, url] of Object.entries(routes)) {
        methods = {...methods, [name]: _manifestNetworkHandler(
            url, 
            successCallback || _aquaCore.resolveSuccessCallback(id), 
            errorCallback || _aquaCore.resolveErrorCallback(id)
        ) };
    }

    return methods;
}

const _aquaCore = {
    createComponentMeta(id) {
        window._aquastrap.component = [
            ...window._aquastrap.component,
            {
                id: id, 
                config: {}
            }
        ];
    },
    setComponentMeta(id, { prop, value }) {
        const componentIndex = window._aquastrap.component.findIndex(c => c.id === id);
        const componentItem = window._aquastrap.component[componentIndex];

        let modify = null;

        switch (prop) {
            case 'config':
                modify = {
                    ...componentItem,
                    config: Object.assign({}, componentItem.config, { 
                        ...( _hasProperty(value, 'success') && {success: value.success} ),
                        ...( _hasProperty(value, 'error') && {error: value.error} )
                    })
                }

                break;
        
            default:
                break;
        }

        window._aquastrap.component = [
            ...window._aquastrap.component.slice(0, componentIndex),
            modify,
            ...window._aquastrap.component.slice(componentIndex + 1)
        ];
    },
    setGlobalConfig({ prop, value }) {
        switch (prop) {
            case 'config':
                window._aquastrap.config = {
                    ...window._aquastrap.config,
                    ...( _hasProperty(value, 'success') && {success: value.success} ),
                    ...( _hasProperty(value, 'error') && {error: value.error} )
                };

                break;
        
            default:
                break;
        }
        
    },
    resolveSuccessCallback(id) {
        const componentIndex = window._aquastrap.component.findIndex(c => c.id === id);
        const component = componentIndex !== -1 ? window._aquastrap.component[componentIndex] : undefined;
        const globalConfig = window._aquastrap.config;

        if(component && _hasProperty(component.config, 'success') && typeof component.config.success === 'function') {
            return component.config.success;
        }

        if(_hasProperty(globalConfig, 'success')) {
            return globalConfig.success;
        }

        return () => {};
    },
    resolveErrorCallback(id) {
        const componentIndex = window._aquastrap.component.findIndex(c => c.id === id);
        const component = componentIndex !== -1 ? window._aquastrap.component[componentIndex] : undefined;
        const globalConfig = window._aquastrap.config;

        if(component && _hasProperty(component.config, 'error') && typeof component.config.error === 'function') {
            return component.config.error;
        }

        if(_hasProperty(globalConfig, 'error')) {
            return globalConfig.error;
        }

        return () => {};
    },
}

function _aquaGenerate(routes, id) {
    return {
        successCallback: null,
        errorCallback: null,
        on(config) {
            if(_hasProperty(config, 'success')) this.successCallback = config.success;
            if(_hasProperty(config, 'error')) this.errorCallback = config.error;

            return {_m: _replicatePublicMethods(routes, id, this.successCallback, this.errorCallback) };
        },
        _r: routes,
        _m: _replicatePublicMethods(routes, id)
    }
}

function _setAquaConfig(configs, id = '') {
    if(! id) {
        _aquaCore.setGlobalConfig({ prop: 'config', value: configs });

        return;
    }

    const componentIndex = window._aquastrap.component.findIndex(c => c.id === id);
    if(componentIndex === -1) {
        _aquaCore.createComponentMeta(id);
    }

    _aquaCore.setComponentMeta(id, { prop: 'config', value: configs });
}


function _registerAquaConfig(id = '') {
    return {
        onSuccess(succesCallback) {
            _setAquaConfig({success: succesCallback}, id);
            return this;
        },
        onError(errCallback) {
            _setAquaConfig({error: errCallback}, id);
            return this;
        },
    }
}